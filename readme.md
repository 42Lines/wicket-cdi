Wicket-CDI provides integration of CDI into Wicket

## Features

#### Injection and LifeCycle

* `Application` instance will be injected and its `@PostConstruct` methods will be invoked. Upon shutdown `@PreDestroy` methods will be invoked.
* `Session` instances will be injected and its `@PostConstruct` methods will be invoked. `@PreDestroy` methods will not be invoked because servlet containers only notify after session has been destroyed.
* `Component` instances will be injected. `@PostConstruct` methods will not be called because component injection happens in the base constructor and so if invoked these methods would run before the constructor of the class they are defined in has finished. `@PreDestroy` methods will not be called because there is no clear point at which a component instance is retired.
* `Behavior` instances will be injected. `@PostConstruct` and `@PreDestroy` methods have the semantics as methods in `Component`.

#### Automatic Propagation of Long Running (Non-Transient) Conversations

Wicket-CDI supports three different conversation propagation modes:

* `NONE` - conversations are not propagated across requests even if conversation is marked as non-transient
* `NONBOOKMARKABLE` - conversations marked as non-transient are propagated page-to-page as long as page navigation is non-bookmarkable (`setResponsePage(anotherPageInstance);`). The propagation happens using page instance metadata so urls are not effected.
* `ALL` - conversations marked as non-transient are propagated across all requests. The conversation id is encoded in a `cid` parameter of every url generated by Wicket.

`NONBOOKMARKABLE` mode offers a compromise between an all manual solution (`NONE`) and an all out propagation (`ALL`) by giving the developer a fairly easy way to define the scope for long-running conversations.

#### CDI-Aware RequestCycleListener Extension

Wicket-CDI provides a `ICdiAwareRequestCycleListener` mixin which allows request cycle listeners to take advantage of two new events:

* `onAfterConversationActivated()` - called after a non-transient conversation is started or a long-running conversation is activated
* `onBeforeConversationDeactivated()` - called right before the current conversation is deactivated at the end of request processing

This allows request cycle listeners to implement `onBegin/EndRequest` functionality but inside an active conversational context.

#### Injection of Unmanaged (aka NonContextual) Instances

It happens often that an unmanaged instance such as a `Behavior` or `Session` needs to be injected. Wicket-CDI provides a simple API to do just that:

`CdiContainer.get().getNonContextualManager().postCreate(instance);`

Invoking this method on the `instance` will cause its injection points to be injected as well as any `@PostConstruct` methods to be invoked. There is also a symmetrical cleanup method which can be used to release any resources held by an unmanaged instance:

`CdiContainer.get().getNonContextualManager().preDestroy(instance);`

Invocation of this method will invoke any `@PreDestroy` methods as well as release all injected resources.

## Installation

Wicket-CDI depends on seam-conversation module to activate and deactivate conversational contexts, so you will need a seam-conversation module specific to your CDI container. For example, for JBoss Weld:

    <dependency>
        <groupId>org.jboss.seam.conversation</groupId>
        <artifactId>seam-conversation-weld</artifactId>
		<version>3.0.0.CR2</version> <!-- TODO check for latest version -->
    </dependency>

Then add the Wicket-CDI module:

    <dependency>
        <groupId>net.ftlines.wicket-cdi</groupId>
        <artifactId>wicket-cdi</artifactId>
		<version>1.0</version> <!-- TODO check for latest version -->
    </dependency>

## Configuration

Configuration of Wicket-CDI is done via a `CdiConfiguration` object that uses a simple fluent api:

    public class MyApplication extends WebApplication {
	    protected void init() {
            BeanManager beanManager=retrieveBeanManagerUsingCdiContainerSpecificApi();
            
			new CdiConfiguration(beanManager)
                .setPropagation(ConversationPropagation.NONBOOKMARKABLE)
                .configure(this);
	    }
    }

Example code retrieving the BeanManager from Weld running in a servlet container:

    import org.jboss.weld.environment.servlet.Listener;
	...
    public class MyApplication extends WebApplication {
	    protected void init() {
            BeanManager manager = (BeanManager)getServletContext().getAttribute(Listener.BEAN_MANAGER_ATTRIBUTE_NAME);
        }
    }

## Copyright and License

Copyright 2012 42Lines Inc

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this work except in
compliance with the License. You may obtain a copy of the License in the LICENSE file, or at:

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
